# thoughts

有一部名为《独木桥》的短剧让我深有感触，讲的就是伴随着成长，人认识自己、寻找自己、宽容自己和接受自己的过程。

能跟自己对话的人，只能是自己。
因为只有和自己对话，才能找到自己内心深处的向往和热爱，才能在面对诸多外在诱惑和干扰时，更好的选择和舍弃，才能更懂得后退的智慧。

---

https://collabfund.com/blog/how-to-read-lots-of-inputs-and-a-strong-filter/

主要观点

- 大多数书籍无需读到最后一页, 只需要一个总结。
- 广泛接触不同书籍并有强大的过滤机制很重要。
- 读书目的不应局限于完成每一本书, 而是从大量信息中快速找到有价值的内容。

作者提出了判断一本书是否值得继续读下去的标准。他建议在阅读的前 10 分钟内，如果对书籍不感兴趣，就应该果断地放弃。这也算及早
return 的一种方式吧。

作者认为，读书和学习是密切相关的。通过大量接触不同的书籍和信息，读者可以拓宽视野，获得新的见解。然而，仅仅依靠个人经历的狭小世界是不够的；
因此，必须有一个强大的过滤机制来处理这些信息，以避免因选择过多而陷入瘫痪。作者强调，良好的阅读习惯能够促进更有效的学习和知识的积累。

## web UI 设计系统参考

- atlassian https://atlassian.design/
- Salesforce’s Lightning design system
- shopify https://polaris.shopify.com/
- Github Primer https://primer.style/design/guides/introduction/
- reshape https://reshaped.so/
- carbon https://carbondesignsystem.com/

相关参考：

- [x] [Design Systems, when and how much? — Diana Mounter](https://youtu.be/Hx02SaL_IH0)
- [x] [The Difference Between Design Systems, Pattern Libraries, Style Guides & Component Libraries](https://www.uxpin.com/studio/blog/design-systems-vs-pattern-libraries-vs-style-guides-whats-difference/)
- []
  设计系统术语 [Design Systems Glossary](https://web.archive.org/web/20220620075140/https://superfriendly.com/design-systems/glossary/)

---

```
如何学习一门编程语言:

学习基本变量类型，基本语句语法
学习高级数据结构，例如集合，dict 等
回顾版本迭代历史，把握关键特性更新
探索 sdk 标准库，或者成为内置库
探索社区第三方优秀工具库，框架
学习如何发布自己的库，并努力维持一段时间的迭代
基于库的学习，学习复杂框架的设计。


技术的浪潮迭代:
构造自己的知识体系，网上很容易找到很多技术大佬的技术笔记以及文章，他们的文章质量很好，数据字数也很大。但是，这些对于自己去实际理解来说，吸收率却不一定高，因为这不是经过自己深度思考得出的知识总结。对于别人是 100%，对于你而言，看完之后吸收率可能是 30%。因此，对于别人的知识，包含教程，书籍，文章，最好要经过自身理解和分析，吸收最精华的部分，不断来完善自己的体系。如果是很优秀的资料，可以引入外链参考。

github 高级搜索：
in：readme 二次元 stars：100 language：java

web 前端：
表单式（php，jsp）整个页面刷新
ajax 请求，局部刷新，jquery 时代
MVC 时代，前端框架早期发展阶段，backbone 这类
MVVM 时代，前端框架中期发展阶段
angular/vue/react

跨平台之移动端：
phonegap/cordova/ionic weview 时代
，性能差
react native/weex hybrid 时代
flutter 自定义渲染时代
kotlin ？
此外，原生开发一直都在，高成本高性能，我才叫 native。

跨平台之桌面端：
传统 QT，原生模式
electron ，浏览器套壳，笨重，前后端语言高度统一，js 为主力。
tauri，前端 js，后端 rust
flutter ？

ssh 工具:
永久抛弃 xshell
windterm
tabby
mobaterm
powershell 和 ssh 配置 openssh


api 文档生成
apidoc
yapi
swagger

```

```
前端入门：前端发展史与前端基础
前端入门：自制 ui 框架
前端入门：自制 mvvm 框架

【限流算法】
计数器（固定窗口）：可能会出现分界点领域流速大约为限流阈值 2 倍的情况。
例子：A 接口一分钟只能请求 100 次。
每次请求过来，合理标识这个请求到缓存，counter 加 1，如果合计超过 100 并且该请求与最早的一个请求还处于 1 分钟内，那么就抛弃该请求。

临界问题出现的原因是限流机制过于粗糙，粒度不够细。滑动窗口可以解决这个问题。

滑动窗口：
每过 10 秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器 counter，比如当一个请求 在 0:35 秒的时候到达，那么 0:30~0:39 对应的 counter 就会加 1。
那么，采取上面的流量攻击方式，0:50-0:59 给予 100 次请求，一旦到了 1:00，如果继续请求，那么就会超出限制，抛弃后续请求。

其实，计数器算法就是退化版的滑动时间窗口。只是窗口没有被切分，只有一个大格。上面的时间窗口是 6 小格。我们已经意识到窗口切分的好处，那么坏处呢？如果窗口切的很细，那么小格会很多，此时代码逻辑就变复杂，而且也没必要。

漏斗：限流机制稳定，流速稳定。但是过于死板，因为这个流出速度是固定的。有时你会抱怨不能很好地压榨计算资源，有时又会抱怨流出速度设置太大，导致限流效果没有明显作用。
因此不能很好地应对突发大流量。

令牌桶：生产令牌的速度固定，流出速率随意，只要令牌桶的令牌数大于请求的令牌，那么就允许消费。否则拒绝。

可以将令牌桶看作漏斗的反转。他们的输入和输入刚好是相反的特性。


【缓存三种情况】
缓存击穿：某个访问量大的 key 过期，导致流量直接打入存储层。
1. 加锁更新。get 时让一个线程加锁更新，其他线程等待。
2. 设置缓存永不过期，异步定时轮询更新。这个一般不适用，因为会导致双写短暂不一致。局限性太大。

缓存穿透：某个访问的 key 根本不存在，导致必然跳过缓存层，打入存储层。
缓存空对象：占有缓存空间。
在缓存和存储之间使用 bloom 过滤器：先 bloom 判断是否存在，不存在的话就不要访问存储层。

缓存雪崩：
某一个时刻大量缓存失效。

发生场景：缓存服务器意外丢失宕机丢失缓存。或定时失效发生。

策略：
提高缓存可用。缓存集群，或多级缓存。
过期时间。过期时间添加随机偏移，均匀过期。热点数据尽量不过期。
熔断降级。建立缓存检测机制。发现缓存几乎没有作用，而流量很大时，及时熔断非核心 api。保证不会被流量淹没。

【缓存双写一致性：】
也就是缓存和存储层的一致性。

延迟双删。
mq 延迟删除。
binlog


【请求处理：】
防止重复提交。
合理标识请求，设置重复的满足条件。例如极断的时间范围内，多次 payload 相同的请求。
使用 redis。

多次请求幂等。
数据库使用分布式唯一 id，例如雪花。
分布式锁。
请求 token。
乐观锁。（仅更新操作）

【分库分表 vs 主从复制，读写分离】
分库分表，解决的问题是单库单表数据量过大的问题。因为单表过大会导致查询树的深度过大，性能下降明显。
此时，数据还是只有一份。只有一个数据库实例。承受的数据库连接数有限。因此，不管你怎么分，一旦用户读写访问量过大，依旧会出现连接数瓶 jin。

为了解决访问量远大于单数据库的连接数上限的问题，需要水平扩展数据库实例。这就是主从复制要解决的问题所在。
主从复制可以很好得提升数据库能够承受的连接数上限，读写分离后。对于读多写少的场景，有明显效果。

【web server 的连接数瓶颈】
nginx 作为优秀的网关代理。可以增加并发连接数。提升应用的连接数上限。

而应用 tomcat，undertow，apacha 的最大连接数为几百到几千。此时很容易成为瓶颈。于是考虑多个同构的 app 实例，才能应对更多的用户请求。但是传统应用业务都在一个 app 中，资源消耗太大。于是诞生了微服务，将业务边界识别，解耦为小的服务。使用 docker 或者 k8s 来运行多实例。

【秒杀系统设计】
https://b23.tv/FPRXMIL


web 安全：
xss
csrf
ssrf

```

```
快照，以及变更数据捕获（写日志）是保存可变状态的两种思路。
记录系统 -> 缓存 + 搜索索引 + 分析系
```

- 持续集成是指将团队成员的代码集成到共享代码库中，并通过自动化测试来验证代码是否可以正常工作。
- 持续交付是指将软件的构建、测试和部署自动化，以便在任何时候都可以快速、可靠地发布软件。
- 持续部署是指将持续交付的自动化过程推向极致，使得每次代码修改都可以自动部署到生产环境中，而无需人工干预。

```
[代码重构]
一旦函数内部状态过多，变化复杂，那么应该抽象为类。
一旦类状态简单，变化简单，也可以退化为函数。
```

```
[产品开发建议]
尽早交付 MVP（最小可行产品），然后广而告之，开始慢慢迭代。
```

```
[文档维护]
《文档与软件：可持续的开发》
对于 docs：markdown 即文档，文档即页面。
对于功能：文档即功能。没有被文档描述的功能，都不会被视为功能，可能随时变更。
文档如何生成：代码即文档。但是将文档全部写在代码中，会使得行数很大，此时抽离出接口，可以在一定程度上缓解这个情况。
活文档的重要性。
把从代码中挖掘系统功能的过程叫做“系统考古学”，从遗留古老的代码中推导功能是很可怕的事情。

理想的解决方案是一种易于维护并且维护成本较低的文档系统，这样即便频繁改动底层的编程语言代码，它也还能与系统功能保持一致。
事实上，任何一种全面的文档都面临着维护成本高昂的问题。以我的经验来看，改动过时的内容不是主要的成本所在，
花时间去找出需要改动的地方通常才是成本较高的地方。

如果我拥有的文档不是自动化的，我就不会信任它。那种文档是未经实践检验的，说明了自动化文档、经过验证的文档的重要性。这样文档可行度很高。
如果是完全手写，凭借软件工程师水平写的，可行度就会下降。
```

```
[如何学习一门编程语言]

1. wiki 了解历史版本发展；
2. 了解该语言各版本主要特性 + 实践并归档 demo 代码；
3. 了解该语言的生态环境，常用开源库，著名框架；
4. 了解该语言主要适用场景，前端，后端，还是客户端 App？
5. [进阶] 阅读该语言源码，例如 JDK，或者优秀项目代码。
```


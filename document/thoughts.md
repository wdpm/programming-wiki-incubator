# thoughts

有一部名为《独木桥》的短剧让我深有感触，讲的就是伴随着成长，人认识自己、寻找自己、宽容自己和接受自己的过程。

能跟自己对话的人，只能是自己。
因为只有和自己对话，才能找到自己内心深处的向往和热爱，才能在面对诸多外在诱惑和干扰时，更好的选择和舍弃，才能更懂得后退的智慧。 

---



## web UI设计系统参考
- atlassian https://atlassian.design/
- Salesforce’s Lightning design system
- shopify https://polaris.shopify.com/
- Github Primer https://primer.style/design/guides/introduction/
- reshape https://reshaped.so/
- carbon https://carbondesignsystem.com/

相关参考：
- [x] [Design Systems, when and how much? — Diana Mounter](https://youtu.be/Hx02SaL_IH0)
- [x] [The Difference Between Design Systems, Pattern Libraries, Style Guides & Component Libraries](https://www.uxpin.com/studio/blog/design-systems-vs-pattern-libraries-vs-style-guides-whats-difference/)
- [ ] 设计系统术语 [Design Systems Glossary](https://web.archive.org/web/20220620075140/https://superfriendly.com/design-systems/glossary/)
---

```
如何学习一门编程语言:

学习基本变量类型，基本语句语法
学习高级数据结构，例如集合，dict等
回顾版本迭代历史，把握关键特性更新
探索sdk标准库，或者成为内置库
探索社区第三方优秀工具库，框架
学习如何发布自己的库，并努力维持一段时间的迭代
基于库的学习，学习复杂框架的设计。


技术的浪潮迭代:
构造自己的知识体系，网上很容易找到很多技术大佬的技术笔记以及文章，他们的文章质量很好，数据字数也很大。但是，这些对于自己去实际理解来说，吸收率却不一定高，因为这不是经过自己深度思考得出的知识总结。对于别人是100%，对于你而言，看完之后吸收率可能是30%。因此，对于别人的知识，包含教程，书籍，文章，最好要经过自身理解和分析，吸收最精华的部分，不断来完善自己的体系。如果是很优秀的资料，可以引入外链参考。

github高级搜索：
in：readme 二次元 stars：100 language：java

web前端：
表单式（php，jsp）整个页面刷新
ajax请求，局部刷新，jquery时代
MVC时代，前端框架早期发展阶段，backbone这类
MVVM时代，前端框架中期发展阶段
angular/vue/react

跨平台之移动端：
phonegap/cordova/ionic weview时代
，性能差
react native/weex hybrid时代
flutter 自定义渲染时代
kotlin ？
此外，原生开发一直都在，高成本高性能，我才叫native。

跨平台之桌面端：
传统QT，原生模式
electron ，浏览器套壳，笨重，前后端语言高度统一，js为主力。
tauri，前端js，后端rust
flutter ？

ssh工具:
永久抛弃xshell
windterm
tabby
mobaterm
powershell 和ssh配置 openssh


web 服务端框架
-

数据库选择
-

画图工具的选择：
draw.io =》diagrams.net 各种风格，GUI拖拽
mermaid-js 基于markdown语法的流程图
excalidraw 手绘风格，GUI拖拽
plant UML 文本控制的uml图例
dot语言 + graphviz 画图工具。基于代码文本。

权衡：
如果对于流程图要求比较规范，例如绝对对齐，优先考虑基于代码文本的生成方式。
如果想要活泼自由的风格，可以选取gui拖拽风格的生成方式。

api 文档生成
apidoc
yapi
swagger

```

```
前端入门：前端发展史与前端基础
前端入门：自制ui框架
前端入门：自制mvvm框架

【限流算法】
计数器（固定窗口）：可能会出现分界点领域流速大约为限流阈值2倍的情况。
例子：A接口一分钟只能请求100次。
每次请求过来，合理标识这个请求到缓存，counter加1，如果合计超过100并且该请求与最早的一个请求还处于1分钟内，那么就抛弃该请求。

临界问题出现的原因是限流机制过于粗糙，粒度不够细。滑动窗口可以解决这个问题。

滑动窗口：
每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。
那么，采取上面的流量攻击方式，0:50-0:59给予100次请求，一旦到了1:00，如果继续请求，那么就会超出限制，抛弃后续请求。

其实，计数器算法就是退化版的滑动时间窗口。只是窗口没有被切分，只有一个大格。上面的时间窗口是6小格。我们已经意识到窗口切分的好处，那么坏处呢？如果窗口切的很细，那么小格会很多，此时代码逻辑就变复杂，而且也没必要。

漏斗：限流机制稳定，流速稳定。但是过于死板，因为这个流出速度是固定的。有时你会抱怨不能很好地压榨计算资源，有时又会抱怨流出速度设置太大，导致限流效果没有明显作用。
因此不能很好地应对突发大流量。

令牌桶：生产令牌的速度固定，流出速率随意，只要令牌桶的令牌数大于请求的令牌，那么就允许消费。否则拒绝。

可以将令牌桶看作漏斗的反转。他们的输入和输入刚好是相反的特性。


【缓存三种情况】
缓存击穿：某个访问量大的key过期，导致流量直接打入存储层。
1.加锁更新。get时让一个线程加锁更新，其他线程等待。
2.设置缓存永不过期，异步定时轮询更新。这个一般不适用，因为会导致双写短暂不一致。局限性太大。

缓存穿透：某个访问的key根本不存在，导致必然跳过缓存层，打入存储层。
缓存空对象：占有缓存空间。
在缓存和存储之间使用bloom过滤器：先bloom判断是否存在，不存在的话就不要访问存储层。

缓存雪崩：
某一个时刻大量缓存失效。

发生场景：缓存服务器意外丢失宕机丢失缓存。或定时失效发生。

策略：
提高缓存可用。缓存集群，或多级缓存。
过期时间。过期时间添加随机偏移，均匀过期。热点数据尽量不过期。
熔断降级。建立缓存检测机制。发现缓存几乎没有作用，而流量很大时，及时熔断非核心api。保证不会被流量淹没。

【缓存双写一致性：】
也就是缓存和存储层的一致性。

延迟双删。
mq延迟删除。
binlog


【请求处理：】
防止重复提交。
合理标识请求，设置重复的满足条件。例如极断的时间范围内，多次payload相同的请求。
使用redis。

多次请求幂等。
数据库使用分布式唯一id，例如雪花。
分布式锁。
请求token。
乐观锁。（仅更新操作）

【分库分表 vs 主从复制，读写分离】
分库分表，解决的问题是单库单表数据量过大的问题。因为单表过大会导致查询树的深度过大，性能下降明显。
此时，数据还是只有一份。只有一个数据库实例。承受的数据库连接数有限。因此，不管你怎么分，一旦用户读写访问量过大，依旧会出现连接数瓶jin。

为了解决访问量远大于单数据库的连接数上限的问题，需要水平扩展数据库实例。这就是主从复制要解决的问题所在。
主从复制可以很好得提升数据库能够承受的连接数上限，读写分离后。对于读多写少的场景，有明显效果。

【web server的连接数瓶颈】
nginx作为优秀的网关代理。可以增加并发连接数。提升应用的连接数上限。

而应用tomcat，undertow，apacha的最大连接数为几百到几千。此时很容易成为瓶颈。于是考虑多个同构的app实例，才能应对更多的用户请求。但是传统应用业务都在一个app中，资源消耗太大。于是诞生了微服务，将业务边界识别，解耦为小的服务。使用docker或者k8s来运行多实例。

【秒杀系统设计】
https://b23.tv/FPRXMIL


web安全：
xss
csrf
ssrf

```

```
快照，以及变更数据捕获（写日志）是保存可变状态的两种思路。
记录系统 -> 缓存 + 搜索索引 +分析系
```

- 持续集成是指将团队成员的代码集成到共享代码库中，并通过自动化测试来验证代码是否可以正常工作。
- 持续交付是指将软件的构建、测试和部署自动化，以便在任何时候都可以快速、可靠地发布软件。
- 持续部署是指将持续交付的自动化过程推向极致，使得每次代码修改都可以自动部署到生产环境中，而无需人工干预。

```
[代码重构]
一旦函数内部状态过多，变化复杂，那么应该抽象为类。
一旦类状态简单，变化简单，也可以退化为函数。
```
```
[产品开发建议]
尽早交付MVP（最小可行产品），然后广而告之，开始慢慢迭代。
```
```
[文档维护]
《文档与软件：可持续的开发》
对于docs：markdown即文档，文档即页面。
对于功能：文档即功能。没有被文档描述的功能，都不会被视为功能，可能随时变更。
文档如何生成：代码即文档。但是将文档全部写在代码中，会使得行数很大，此时抽离出接口，可以在一定程度上缓解这个情况。
活文档的重要性。
把从代码中挖掘系统功能的过程叫做“系统考古学”，从遗留古老的代码中推导功能是很可怕的事情。

理想的解决方案是一种易于维护并且维护成本较低的文档系统，这样即便频繁改动底层的编程语言代码，它也还能与系统功能保持一致。
事实上，任何一种全面的文档都面临着维护成本高昂的问题。以我的经验来看，改动过时的内容不是主要的成本所在，
花时间去找出需要改动的地方通常才是成本较高的地方。

如果我拥有的文档不是自动化的，我就不会信任它。那种文档是未经实践检验的，说明了自动化文档、经过验证的文档的重要性。这样文档可行度很高。
如果是完全手写，凭借软件工程师水平写的，可行度就会下降。
```

## documentation tool

- graphviz
  - http://www.webgraphviz.com/
  - http://dreampuf.github.io/GraphvizOnline/
  - http://www.graphviz.org/documentation/
- https://www.diagrams.net/ (formerly called draw.io)
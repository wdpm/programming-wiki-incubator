00 函数套娃，一层一层包装
01 一层嵌套，修饰器没有参数。
02 两层嵌套，修饰器含有参数。此时无法再使用timer这种形式，而是必须为timer()
03 使用 @wraps(func) 来修复丢失的原函数属性
04 使用 `def delayed_start(func=None, *, duration=1):`格式来支持timer形式的调用。
05 类实现的装饰器可分为两种，一种是“函数替换”，另一种是“实例替换”
06 使用 wrapt 模块编写的装饰器，1.解决了类方法兼容问题，2.代码嵌套层级也比普通装饰器少，变得更扁平、更易读。
07 使用类装饰器替代元类，元类可读性太差，类修饰器可读性很好。
08 区分装饰器模式。
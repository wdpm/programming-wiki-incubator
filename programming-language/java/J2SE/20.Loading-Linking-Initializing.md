# Loading Linking Initializing

## 概述

Java虚拟机动态**加载，链接和初始化**类和接口。

- 加载：查找具有特定名称的类或接口类型的二进制表示，并从该二进制表示形式创建类或接口。
- 链接：获取类或接口，并将其组合到Java虚拟机的运行时状态，以便可以执行。
- 初始化：执行类或接口的初始化方法``<clinit> ``

## 运行时常量池

Java虚拟机维护每个类型的常量池，这是一种运行时数据结构，可满足常规编程语言实现的符号表的许多用途。

类或接口的二进制表示中的constant_pool表用于在创建类或接口时构造运行时常量池。运行时常量池中的所有引用最初都是符号性的。运行时常量池中的符号引用是从类或接口的二进制表示形式的结构派生的。 

## JVM启动

Java虚拟机通过使用bootstrap类加载器创建一个初始类来启动，该类以与实现相关的方式指定。然后，Java虚拟机将链接初始类，对其进行初始化，然后调用公共类方法void main（String []）。该方法的调用将推动所有进一步的执行。构成main方法的Java虚拟机指令的执行可能会导致其他类和接口的链接（并因此创建），以及其他方法的调用。 

## 加载

有两种类加载器：Java虚拟机提供的引导类加载器，用户定义的类加载器。每个用户定义的类加载器都是抽象类ClassLoader的子类的实例。应用程序使用用户定义的类加载器，以扩展Java虚拟机动态加载并由此创建类的方式。用户定义的类加载器可用于创建源自用户定义的源的类。例如，可以通过网络下载类，动态生成类或从加密文件中提取类。

## 链接

链接类或接口包括在必要时**验证和准备该类或接口**，其直接超类，其直接超接口及其元素类型（如果是数组类型）。类或接口中符号引用的解析是链接过程中的可选部分。 

该规范为实现链接活动（以及由于递归，加载）发生的时间提供了实现的灵活性，但前提是必须保留以下所有属性： 

-  类或接口在链接之前已完全加载。 
-  在初始化类或接口之前，必须对其进行完全验证和准备。 
-  链接期间检测到的错误会抛出到程序中某个位置，在该位置上，程序将采取某些操作，这些操作可能直接或间接地需要链接到错误所涉及的类或接口。 

例如，Java虚拟机实现可以选择在使用某个类或接口时分别解析每个符号引用（“懒”或“延迟”解析），或者在验证类时一次全部解决（ “eager”或“静态”解析）。这意味着在某些实现中，在初始化类或接口之后，解析过程可能会继续。无论采用哪种策略，在解析过程中检测到的任何错误都必须抛出在程序中的直接或间接使用对类或接口的符号引用的某个点。 

### 验证

验证**确保类或接口的二进制表示在结构上正确**。验证可以导致加载其他类和接口，但不必导致对它们进行验证或准备。

### 准备

准备包括**为类或接口创建静态字段，并将这些字段初始化为其默认值**。这不需要执行任何Java虚拟机代码。静态字段的显式初始化程序是初始化的一部分，而不是准备工作。 

### 解析

解析是**根据运行时常量池中的符号引用动态确定具体值的过程**。 

## 初始化

类或接口的初始化包括执行其类或接口的初始化方法。

只能由于以下原因而初始化类或接口： 

-  引用类或接口的任何Java虚拟机指令（new，getstatic，putstatic或invokestatic）的执行。这些指令都通过字段引用或方法引用直接或间接引用类。 

- 首次调用java.lang.invoke.MethodHandle实例，该实例是Java虚拟机对方法句柄进行解析的结果，并且具有2（REF_getStatic），4（REF_putStatic），或6（REF_invokeStatic）。
- 在类库中调用某些反射方法，例如，在类Class或包java.lang.reflect中。 
- 子类初始化。 
- 在Java虚拟机启动时将其指定为初始类。

## 绑定本地方法实现

绑定可以将用Java编程语言以外的其他语言编写并实现本机方法的功能集成到Java虚拟机中，以便可以执行该功能。

## JVM的退出

当某些线程调用Runtime类或System类的exit方法或Runtime类的halt方法，并且安全管理器允许退出或停止操作时，Java虚拟机将退出。JNI（Java本机接口）规范描述了使用JNI调用API加载和卸载Java虚拟机时Java虚拟机的终止。

## 参考

- [1]  https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.1 

